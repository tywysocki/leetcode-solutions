{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Welcome to my personal site, your gateway to my world of software development and computer science. Whether you're an employer seeking a talented iOS developer, a fellow student navigating the world of computer science, or a coding enthusiast, this website is here to serve your needs.</p>"},{"location":"#showcasing-my-skills","title":"Showcasing My Skills","text":"<p>Explore my portfolio of iOS projects, each backed by strong design principles and robust code. Whether it's enhancing user experiences or optimizing performance, my work speaks for itself.</p>"},{"location":"#documenting-my-journey","title":"Documenting My Journey","text":"<p>Embark on a journey with me through the realm of computer science. I document my experiences, challenges, and achievements as a developer. Follow along as I conquer complex subjects and apply them to real-world problems.</p>"},{"location":"#learn-and-connect","title":"Learn and Connect","text":"<p>This website is not just about showcasing my skills; it's also a platform for learning and connecting with like-minded individuals. Dive into my LeetCode solutions, explore my coding insights, and join the discussion. Let's learn and grow together.</p>"},{"location":"#key-sections","title":"Key Sections","text":""},{"location":"#leetcode-solutions","title":"LeetCode Solutions","text":"<p>Dive into the world of coding challenges. Explore multiple solutions for each problem, along with detailed explanations.</p>"},{"location":"#portfolio","title":"Portfolio","text":"<p>Explore my iOS development projects. Each project comes with detailed descriptions, technologies used, and outcomes achieved.</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#array","title":"Array","text":"<ul> <li>Remove Duplicates from Sorted Array</li> <li>Two Sum</li> <li>Constrained Subsequence Sum</li> <li>Max Dot Product of Two Subsequences</li> <li>Median of Two Sorted Arrays</li> <li>Sudoku Solver</li> <li>Container wih Most Water</li> </ul>"},{"location":"tags/#back-tracking","title":"Back Tracking","text":"<ul> <li>Sudoku Solver</li> </ul>"},{"location":"tags/#backtracking","title":"Backtracking","text":"<ul> <li>N-Queens II</li> </ul>"},{"location":"tags/#binary-search","title":"Binary Search","text":"<ul> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#binary-tree","title":"Binary Tree","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#breadth-first-search","title":"Breadth-First Search","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#depth-first-search","title":"Depth First Search","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#divide-and-conquer","title":"Divide and Conquer","text":"<ul> <li>Median of Two Sorted Arrays</li> <li>Merge k Sorted Lists</li> </ul>"},{"location":"tags/#dynamic-programming","title":"Dynamic Programming","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Longest Valid Parentheses</li> <li>Max Dot Product of Two Subsequences</li> <li>Number of Ways to Stay in the Same Place After Some Steps</li> <li>Regular Expression Matching</li> <li>Wildcard Matching</li> <li>Integer Break</li> </ul>"},{"location":"tags/#dynamic-programmming","title":"Dynamic Programmming","text":"<ul> <li>Longest Palindromic Substring</li> </ul>"},{"location":"tags/#easy","title":"Easy","text":"<ul> <li>Backspace String Compare</li> <li>Palindrome Number</li> <li>Pascals Triangle II</li> <li>Remove Duplicates from Sorted Array</li> <li>Roman to Integer</li> <li>Tenth Line</li> <li>Two Sum</li> </ul>"},{"location":"tags/#graph","title":"Graph","text":"<ul> <li>Parallell Courses III</li> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#greedy","title":"Greedy","text":"<ul> <li>Wildcard Matching</li> <li>Container wih Most Water</li> </ul>"},{"location":"tags/#hard","title":"Hard","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Longest Valid Parentheses</li> <li>Max Dot Product of Two Subsequences</li> <li>Median of Two Sorted Arrays</li> <li>Merge k Sorted Lists</li> <li>N-Queens II</li> <li>Number of Ways to Stay in the Same Place After Some Steps</li> <li>Parallell Courses III</li> <li>Regular Expression Matching</li> <li>Reverse Nodes in k-Group</li> <li>Substring With Concatenation of All Words</li> <li>Sudoku Solver</li> <li>Wildcard Matching</li> </ul>"},{"location":"tags/#hash-table","title":"Hash Table","text":"<ul> <li>Roman to Integer</li> <li>Two Sum</li> <li>Substring With Concatenation of All Words</li> <li>Sudoku Solver</li> <li>Integer to Roman</li> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#heap-priority-queue","title":"Heap (Priority Queue)","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Merge k Sorted Lists</li> </ul>"},{"location":"tags/#linked-list","title":"Linked List","text":"<ul> <li>Merge k Sorted Lists</li> <li>Reverse Nodes in k-Group</li> <li>Add Two Numbers</li> </ul>"},{"location":"tags/#math","title":"Math","text":"<ul> <li>Palindrome Number</li> <li>Roman to Integer</li> <li>Add Two Numbers</li> <li>Integer Break</li> <li>Integer to Roman</li> <li>Reverse Integer</li> </ul>"},{"location":"tags/#matrix","title":"Matrix","text":"<ul> <li>Sudoku Solver</li> </ul>"},{"location":"tags/#medium","title":"Medium","text":"<ul> <li>Add Two Numbers</li> <li>Container wih Most Water</li> <li>Integer Break</li> <li>Integer to Roman</li> <li>Longest Palindromic Substring</li> <li>Longest Substring Without Repeating Characters</li> <li>Reverse Integer</li> <li>String to Integer (atoi)</li> <li>Validate Binary Tree Nodes</li> <li>Zigzag Conversation</li> </ul>"},{"location":"tags/#merge-sort","title":"Merge Sort","text":"<ul> <li>Merge k Sorted Lists</li> </ul>"},{"location":"tags/#monotonic-queue","title":"Monotonic Queue","text":"<ul> <li>Constrained Subsequence Sum</li> </ul>"},{"location":"tags/#queue","title":"Queue","text":"<ul> <li>Constrained Subsequence Sum</li> </ul>"},{"location":"tags/#recursion","title":"Recursion","text":"<ul> <li>Regular Expression Matching</li> <li>Reverse Nodes in k-Group</li> <li>Wildcard Matching</li> <li>Add Two Numbers</li> </ul>"},{"location":"tags/#shell","title":"Shell","text":"<ul> <li>Tenth Line</li> </ul>"},{"location":"tags/#simulation","title":"Simulation","text":"<ul> <li>Backspace String Compare</li> </ul>"},{"location":"tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Substring With Concatenation of All Words</li> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#stack","title":"Stack","text":"<ul> <li>Backspace String Compare</li> <li>Longest Valid Parentheses</li> </ul>"},{"location":"tags/#string","title":"String","text":"<ul> <li>Backspace String Compare</li> <li>Roman to Integer</li> <li>Longest Valid Parentheses</li> <li>Regular Expression Matching</li> <li>Substring With Concatenation of All Words</li> <li>Wildcard Matching</li> <li>Integer to Roman</li> <li>Longest Palindromic Substring</li> <li>Longest Substring Without Repeating Characters</li> <li>String to Integer (atoi)</li> </ul>"},{"location":"tags/#swift","title":"Swift","text":"<ul> <li>Backspace String Compare</li> <li>Palindrome Number</li> <li>Pascals Triangle II</li> <li>Remove Duplicates from Sorted Array</li> <li>Roman to Integer</li> <li>Two Sum</li> <li>Longest Valid Parentheses</li> <li>Max Dot Product of Two Subsequences</li> <li>Median of Two Sorted Arrays</li> <li>Merge k Sorted Lists</li> <li>N-Queens II</li> <li>Number of Ways to Stay in the Same Place After Some Steps</li> <li>Parallell Courses III</li> <li>Regular Expression Matching</li> <li>Reverse Nodes in k-Group</li> <li>Substring With Concatenation of All Words</li> <li>Sudoku Solver</li> <li>Wildcard Matching</li> <li>Container wih Most Water</li> <li>Integer Break</li> <li>Integer to Roman</li> <li>Longest Palindromic Substring</li> <li>Longest Substring Without Repeating Characters</li> <li>Reverse Integer</li> <li>String to Integer (atoi)</li> <li>Zigzag Conversation</li> </ul>"},{"location":"tags/#topological-sorting","title":"Topological Sorting","text":"<ul> <li>Parallell Courses III</li> </ul>"},{"location":"tags/#tree","title":"Tree","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#two-pointer","title":"Two Pointer","text":"<ul> <li>Container wih Most Water</li> </ul>"},{"location":"tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>Backspace String Compare</li> <li>Remove Duplicates from Sorted Array</li> </ul>"},{"location":"tags/#union-find","title":"Union Find","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"portfolio/","title":"Portfolio","text":"<p>Explore my iOS development projects. Each project comes with detailed descriptions, technologies used, and outcomes achieved.</p>"},{"location":"portfolio/openai/","title":"OpenAI","text":"<p>A Swift-based tool used to interact with the OpenAI HTTP APIs.</p>"},{"location":"portfolio/openai/#installation","title":"Installation","text":"<p>To integrate the library, Swift Package Manager is your tool of choice. Add the following dependency to the Package.swift file:</p> <pre><code>.Package(url: \"https://github.com/tywysocki/OpenAI.git\", from: \"1.0.0\")\n</code></pre>"},{"location":"portfolio/openai/#usage","title":"Usage","text":"<p>Import the library:</p> <p><pre><code>import OpenAI\n</code></pre> Create an API key here, and add it to your configuration.</p> <pre><code>let openAI = OpenAI(authToken:\"API_KEY\")\n</code></pre> <p>With this library, you can take advantage of Swift concurrency. The code snippets provided below demonstrate both async/await and completion handler implementations.</p>"},{"location":"portfolio/openai/#completions","title":"Completions","text":"<p>Use the <code>openAI.sendCompletion</code> method to send a request to the completions endpoint of the API. All you need to do is provide the desired text prompt as input, and the model will generate a text completion that is intended to match the context or pattern you provided. Keep in mind that the model's success generally depends on the complexity of the task and quality of your prompt.</p>"},{"location":"portfolio/openai/#completion-handler","title":"Completion handler:","text":"<pre><code>openAI.sendCompletion(with: \"How are you doing today\") { result in // Result&lt;OpenAIModel, OpenAIError&gt;\n    switch result {\n    case .success(let success):\n        print(success.choices.first?.text ?? \"\")\n    case .failure(let failure):\n        print(failure.localizedDescription)\n    }\n}\n</code></pre> <p>async/await:</p> <pre><code>do {\n    let result = try await openAI.sendCompletion(\n        with: \"What is today's date?\",\n        model: .gpt3(.davinci), // optional `OpenAIModelType`\n        maxTokens: 16,          // optional `Int?`\n        temperature: 1          // optional `Double?`\n    )\n    // use result\n} catch {\n    // ...\n}\n</code></pre> <p>For a list of supported models, refer to OpenAIModelType.swift. For detailed information about these models, refer to the OpenAI API Docs.</p>"},{"location":"portfolio/openai/#chat","title":"Chat","text":"<p>Access ChatGPT (aka GPT-3.5) and GPT-4 (beta) using the <code>openAI.sendChat</code> method. The chat models require a series of messages as input, and produce a model-generated message as output. Each element in the <code>chat</code> array is a <code>ChatMessage</code> object, containing a <code>role</code> (either \"system\", \"user\", or \"assistant\") and <code>content</code> (the message content). Typically, conversations begin with a system message (which establishes the behavior of the assistant) followed by alternating user and assistant messages.</p> <p>Example API call:</p> <pre><code>do {\n    let chat: [ChatMessage] = [\n        ChatMessage(role: .system, content: \"You are a helpful assistant.\"),\n        ChatMessage(role: .user, content: \"Who played in the 30th Super Bowl?\"),\n        ChatMessage(role: .assistant, content: \"The 30th Super Bowl was played between the Dallas Cowboys and the Pittsburgh Steelers.\"),\n        ChatMessage(role: .user, content: \"Who won the game?\")\n    ]\n\n    let result = try await openAI.sendChat(with: chat)\n    // use result\n} catch {\n    // ...\n}\n</code></pre> <p>This library supports all API parameters, except for streaming message content that has not been completed yet.</p> <pre><code>do {\n    let chat: [ChatMessage] = [...]\n\n    let result = try await openAI.sendChat(\n        with: chat,\n        model: .chat(.chatgpt),         // optional `OpenAIModelType`\n        user: nil,                      // optional `String?`\n        temperature: 1,                 // optional `Double?`\n        topProbabilityMass: 1,          // optional `Double?`\n        choices: 1,                     // optional `Int?`\n        stop: nil,                      // optional `[String]?`\n        maxTokens: nil,                 // optional `Int?`\n        presencePenalty: nil,           // optional `Double?`\n        frequencyPenalty: nil,          // optional `Double?`\n        logitBias: nil                  // optional `[Int: Double]?`\n    )\n    // use result\n} catch {\n    // ...\n}\n</code></pre>"},{"location":"portfolio/openai/#images","title":"Images","text":"<p>To generate an original image based on a text prompt, use the <code>openAI.sendImages</code> method. For better results, provide a detailed text prompt.</p> <pre><code>openAI.sendImages(with: \"Hand drawn sketch of a Porsche 911.\", numImages: 1, size: .size1024) { result in // Result&lt;OpenAIModel, OpenAIError&gt;\n    switch result {\n    case .success(let success):\n        print(success.data.first?.url ?? \"\")\n    case .failure(let failure):\n        print(failure.localizedDescription)\n    }\n}\n</code></pre>"},{"location":"portfolio/openai/#edits","title":"Edits","text":"<p>To edit text based on a prompt and a modification instruction, use <code>openAI.sendEdits</code>. The method takes a prompt and a modification instruction as input and returns an edited version of the prompt as output.</p> <pre><code>do {\n    let result = try await openAI.sendEdits(\n        with: \"Fix the spelling mistake.\",\n        model: .feature(.davinci),               // optional `OpenAIModelType`\n        input: \"Me name is Ty\"\n    )\n    // use result\n} catch {\n    // ...\n}\n</code></pre>"},{"location":"portfolio/openai/#embeddings","title":"Embeddings","text":"<p>To obtain a vector representation of a text string, make a request to the embeddings endpoint with <code>openAI.sendEmbeddings</code>. The method returns a vector representation of the text string that can be easily consumed by machine learning models and algorithms. For more information and use cases, refer to the API documentation.</p> <pre><code>do {\n    let result = try await openAI.sendEmbeddings(\n        with: \"The service was great and the clerk...\"\n    )\n    // use result\n} catch {\n    // ...\n}\n</code></pre>"},{"location":"portfolio/openai/#moderation","title":"Moderation","text":"<p>The moderation endpoint is a tool you can use to check whether content complies with OpenAI's usage policies. To obtain a classification for a piece of text, send a request to the moderation endpoint with the <code>openAI.sendModeration</code> method.</p> <pre><code>do {\n    let result = try await openAI.sendModeration(\n        with: \"Unmoderated text\",\n        model: .moderation(.latest)     // optional `OpenAIModelType`\n    )\n    // use result\n} catch {\n    // ...\n}\n</code></pre>"},{"location":"portfolio/openai/#license","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2022 - 2023 Tyler Wysocki</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"solutions/","title":"LeetCode Solutions","text":""},{"location":"solutions/easy/backspace-string-compare/","title":"Backspace String Compare","text":"","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/backspace-string-compare/#description","title":"Description","text":"<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if they are equal when both are typed into empty text editors. <code>'#'</code> means a backspace character.</p> <p>Note that after backspacing an empty text, the text will continue empty.</p> Example 1Example 2Example 3 <pre><code>Input: s = \"ab#c\", t = \"ad#c\"\nOutput: true\nExplanation: Both s and t become \"ac\".\n</code></pre> <pre><code>Input: s = \"ab##\", t = \"c#d#\"\nOutput: true\nExplanation: Both s and t become \"\".\n</code></pre> <pre><code>Input: s = \"a#c\", t = \"b\"\nOutput: false\nExplanation: s becomes \"c\" while t becomes \"b\".\n</code></pre>","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/backspace-string-compare/#solution","title":"Solution","text":"<p>Backspace String Compare using Stack-Based Simulation</p>","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/backspace-string-compare/#intuition","title":"Intuition","text":"<p>To solve this problem, we can simulate the typing process for both strings <code>s</code> and <code>t</code> by applying the backspace actions and then comparing the resulting strings.</p>","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/backspace-string-compare/#approach","title":"Approach","text":"<ol> <li> <p>Create two helper functions: one for processing a string with backspaces and one for converting the processed string into the final string.</p> </li> <li> <p>In the <code>processString</code> function, initialize an empty array to represent the stack. Iterate through each character in the input string. If the character is not a backspace ('#'), push it onto the stack. If it is a backspace, pop an element from the stack if the stack is not empty.</p> </li> <li> <p>After processing both strings <code>s</code> and <code>t</code>, apply the <code>convertToString</code> function to both processed strings to get their final representations.</p> </li> <li> <p>Finally, compare the two final strings to check if they are equal. Return <code>true</code> if they are equal, and <code>false</code> otherwise.</p> </li> </ol>","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/backspace-string-compare/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\), where \\(n\\) is the length of the longer string between <code>s</code> and <code>t</code>. We iterate through both strings once.</li> <li>Space complexity: \\(O(n)\\), as we use a stack to store the processed characters.</li> </ul>","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/backspace-string-compare/#code","title":"Code","text":"<pre><code>class Solution {\n    func backspaceCompare(_ s: String, _ t: String) -&gt; Bool {\n        func processString(_ str: String) -&gt; [Character] {\n            var stack = [Character]()\n            for char in str {\n                if char != \"#\" {\n                    stack.append(char)\n                } else if !stack.isEmpty {\n                    stack.removeLast()\n                }\n            }\n            return stack\n        }\n\n        func convertToString(_ arr: [Character]) -&gt; String {\n            return String(arr)\n        }\n\n        let processedS = convertToString(processString(s))\n        let processedT = convertToString(processString(t))\n\n        return processedS == processedT\n    }\n}\n</code></pre>","tags":["Easy","Swift","Two Pointers","String","Stack","Simulation"]},{"location":"solutions/easy/palindrome-number/","title":"Palindrome Number","text":"","tags":["Easy","Swift","Math"]},{"location":"solutions/easy/palindrome-number/#description","title":"Description","text":"<p>LeetCode Problem 9. Palindrome Number</p> <p>Given an integer <code>x</code>, return true if <code>x</code> is a palindrome, and false otherwise.</p> <p>An integer is a palindrome when it reads the same forward and backward. </p> <p>For example, <code>121</code> is a palindrome while <code>123</code> is not.</p>","tags":["Easy","Swift","Math"]},{"location":"solutions/easy/palindrome-number/#solution","title":"Solution","text":"","tags":["Easy","Swift","Math"]},{"location":"solutions/easy/pascals-triangle-2/","title":"Pascals Triangle II","text":"","tags":["Easy","Swift"]},{"location":"solutions/easy/pascals-triangle-2/#description","title":"Description","text":"<p>LeetCode Problem 119. Pascals Triangle II</p> <p>Given an integer <code>rowIndex</code>, return the <code>rowIndex</code><sup>th</sup> (0-indexed) row of the Pascal's triangle.</p>","tags":["Easy","Swift"]},{"location":"solutions/easy/pascals-triangle-2/#solution","title":"Solution","text":"","tags":["Easy","Swift"]},{"location":"solutions/easy/remove-duplicates-from-sorted-array/","title":"Remove Duplicates from Sorted Array","text":"","tags":["Easy","Swift","Array","Two Pointers"]},{"location":"solutions/easy/remove-duplicates-from-sorted-array/#description","title":"Description","text":"<p>LeetCode Problem 26. Remove Duplicates from Sorted Array</p> <p>Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.</p> <p>Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:</p> <p>Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k.</p> <p>Custom Judge:</p> <p>The judge will test your solution with the following code:</p> <pre><code>int[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</code></pre> <p>If all assertions pass, then your solution will be accepted.</p>","tags":["Easy","Swift","Array","Two Pointers"]},{"location":"solutions/easy/remove-duplicates-from-sorted-array/#solution","title":"Solution","text":"","tags":["Easy","Swift","Array","Two Pointers"]},{"location":"solutions/easy/roman-to-integer/","title":"Roman to Integer","text":"","tags":["Easy","Swift","Hash Table","Math","String"]},{"location":"solutions/easy/roman-to-integer/#description","title":"Description","text":"<p>LeetCode Problem</p> <p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p> Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 <p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p> <p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p> <p><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.  <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.  <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</p> <p>Given a roman numeral, convert it to an integer.</p>","tags":["Easy","Swift","Hash Table","Math","String"]},{"location":"solutions/easy/roman-to-integer/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Easy","Swift","Hash Table","Math","String"]},{"location":"solutions/easy/tenth-line/","title":"Tenth Line","text":"","tags":["Easy","Shell"]},{"location":"solutions/easy/tenth-line/#description","title":"Description","text":"<p>LeetCode Problem 195. Tenth Line</p> <p>Given a text file <code>file.txt</code>, print just the 10<sup>th</sup> line of the file.</p> <p>Example:</p> <p>Assume that <code>file.txt</code> has the following content:</p> <pre><code>Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n</code></pre> <p>Your script should output the tenth line, which is:</p> <pre><code>Line 10\n</code></pre> <p>Note:</p> <ol> <li>If the file contains less than 10 lines, what should you output?</li> <li>There's at least three different solutions. Try to explore all possibilities.</li> </ol>","tags":["Easy","Shell"]},{"location":"solutions/easy/tenth-line/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Easy","Shell"]},{"location":"solutions/easy/two-sum/","title":"Two Sum","text":"","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#description","title":"Description","text":"<p>LeetCode Problem 1: Two Sum</p> <p>The Two Sum problem is a classic algorithmic problem. Given an array of integers <code>nums</code> and an integer <code>target</code>, your task is to find two numbers in the array that add up to the <code>target</code>. You can assume that each input will have exactly one solution, and you may not use the same element twice. The answer can be returned in any order.</p> <p>Examples:</p> <ol> <li> <p>Input: <code>nums = [2, 7, 11, 15], target = 9</code> Output: <code>[0, 1]</code> Explanation: Because <code>nums[0] + nums[1] == 9</code>, we return <code>[0, 1]</code>.</p> </li> <li> <p>Input: <code>nums = [3, 2, 4], target = 6</code> Output: <code>[1, 2]</code></p> </li> <li> <p>Input: <code>nums = [3, 3], target = 6</code> Output: <code>[0, 1]</code></p> </li> </ol>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#solution","title":"Solution","text":"<p>To efficiently solve the Two Sum problem, we'll utilize a hash map to keep track of the numbers we've encountered and their indices while iterating through the input array. This approach allows us to swiftly determine if the complement of the current number (i.e., <code>target - currentNumber</code>) has been seen before.</p>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#approach","title":"Approach","text":"<ol> <li> <p>Create an empty dictionary to store numbers and their indices. This dictionary will help us check whether we've encountered a number and its index before.</p> </li> <li> <p>Iterate through the input array <code>nums</code> using a for loop. As we traverse the array, we keep track of the current number and its index.</p> </li> <li> <p>For each number <code>num</code> at index <code>i</code>, calculate the complement as <code>target - num</code>. The complement is the number we need to find in the array to reach the target.</p> </li> <li> <p>Check if the complement is already present in the dictionary. If it is, that means we've seen it before. In this case, we've found our solution, and we can return the indices of the complement and the current number as <code>[dict[complement]!, i]</code>.</p> </li> <li> <p>If the complement is not in the dictionary, add the current number and its index to the dictionary. This allows us to look up the index of the current number later if we encounter the complement.</p> </li> <li> <p>If no valid solution is found after iterating through the entire array, return an empty array to indicate that there's no valid pair of numbers that sum up to the target.</p> </li> </ol>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#complexity","title":"Complexity","text":"<p>Let's analyze the time and space complexity of our solution:</p>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#time-complexity","title":"Time Complexity","text":"<p>The time complexity of this solution is \\(O(n)\\), where \\(n\\) is the number of elements in the input array <code>nums</code>. We iterate through the array once, checking and updating the dictionary.</p>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(n)\\) as well. In the worst case, we may need to store all the elements and their indices in the dictionary, resulting in linear space usage.</p>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/easy/two-sum/#code","title":"Code","text":"<p>Here's the Swift code implementing the Two Sum problem solution using the described approach:</p> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n        // Create a dictionary to store numbers and their indices\n        var numIndices = [Int: Int]()\n\n        // Iterate through the array\n        for i in 0..&lt;nums.count {\n            let num = nums[i]\n            let complement = target - num\n\n            // If the complement is in the dictionary, return the indices\n            if let complementIndex = numIndices[complement] {\n                return [complementIndex, i]\n            }\n\n            // Add the current number and its index to the dictionary\n            numIndices[num] = i\n        }\n\n        // If no solution is found, return an empty array\n        return []\n    }\n}\n</code></pre>","tags":["Easy","Swift","Hash Table","Array"]},{"location":"solutions/hard/constrained-subsequence-sum-1425/","title":"Constrained Subsequence Sum","text":"","tags":["Hard","Array","Dynamic Programming","Queue","Sliding Window","Heap (Priority Queue)","Monotonic Queue"]},{"location":"solutions/hard/constrained-subsequence-sum-1425/#description","title":"Description","text":"<p>LeetCode Problem 1425: Constrained Subsequence Sum</p> <p>Given an integer array <code>nums</code> and an integer <code>k</code>, you need to find the maximum sum of a non-empty subsequence of the array, such that for any two consecutive integers in the subsequence, <code>nums[i]</code> and <code>nums[j]</code> (where <code>i &lt; j</code>), the condition <code>j - i &lt;= k</code> is satisfied. In simpler terms, the elements you choose in the subsequence should be within a maximum distance of <code>k</code> from each other.</p> <p>Example: ```python Input: nums = [10, 4, 8, 1, 2, 6], k = 2 Output: 18 Explanation: The maximum sum subsequence is [10, 4, 4], where the distance between any two elements is at most 2.</p>","tags":["Hard","Array","Dynamic Programming","Queue","Sliding Window","Heap (Priority Queue)","Monotonic Queue"]},{"location":"solutions/hard/constrained-subsequence-sum-1425/#intuition","title":"Intuition","text":"<p>We aim to find the maximum sum of a non-empty subsequence with the constraint that the difference between two consecutive elements in the subsequence should be less than or equal to 'k'. To achieve this, we'll use dynamic programming and a double-ended queue (deque) to optimize the solution.</p>","tags":["Hard","Array","Dynamic Programming","Queue","Sliding Window","Heap (Priority Queue)","Monotonic Queue"]},{"location":"solutions/hard/constrained-subsequence-sum-1425/#approach","title":"Approach","text":"<ol> <li>Initialize a deque to store the indices of maximum values within the last 'k' elements.</li> <li>Create an array 'dp' to store the maximum sum for subsequences ending at each index.</li> <li>Iterate through the 'nums' array.</li> <li>Check and update the deque to maintain valid indices within the last 'k' elements.</li> <li>Calculate the maximum sum for the current index 'i' by considering the value at 'i' and the maximum value from the deque.</li> <li>Update the 'dp' array and the deque as we progress through the array.</li> <li>The result is the maximum value in the 'dp' array.</li> </ol>","tags":["Hard","Array","Dynamic Programming","Queue","Sliding Window","Heap (Priority Queue)","Monotonic Queue"]},{"location":"solutions/hard/constrained-subsequence-sum-1425/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\) - We iterate through the 'nums' array once.</li> <li>Space complexity: \\(O(n)\\) - We use an array 'dp' and a deque for storage.</li> </ul> <p>```swift class Solution {     func constrainedSubsetSum(_ nums: [Int], _ k: Int) -&gt; Int {         let n = nums.count         var dp = Array(repeating: 0, count: n)         dp[0] = nums[0]</p> <pre><code>    // Deque to store the indices of maximum values in the last 'k' elements\n    var deque = [0]\n\n    for i in 1..&lt;n {\n        // Check if the maximum value in the deque is out of range\n        while !deque.isEmpty &amp;&amp; deque.first! &lt; i - k {\n            deque.removeFirst()\n        }\n\n        dp[i] = max(dp[deque.first!], 0) + nums[i]\n\n        // Remove values from the back of the deque that are less than the current dp[i]\n        while !deque.isEmpty &amp;&amp; dp[i] &gt;= dp[deque.last!] {\n            deque.removeLast()\n        }\n\n        deque.append(i)\n    }\n\n    return dp.max()!\n}\n</code></pre> <p>}</p>","tags":["Hard","Array","Dynamic Programming","Queue","Sliding Window","Heap (Priority Queue)","Monotonic Queue"]},{"location":"solutions/hard/longest-valid-parentheses/","title":"Longest Valid Parentheses","text":"","tags":["Hard","Swift","String","Dynamic Programming","Stack"]},{"location":"solutions/hard/longest-valid-parentheses/#description","title":"Description","text":"<p>LeetCode Problem 32. Longest Valid Parentheses</p> <p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, return the length of the longest valid (well-formed) parentheses substring.</p>","tags":["Hard","Swift","String","Dynamic Programming","Stack"]},{"location":"solutions/hard/longest-valid-parentheses/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","String","Dynamic Programming","Stack"]},{"location":"solutions/hard/max-dot-product-of-two-subsequences/","title":"Max Dot Product of Two Subsequences","text":"","tags":["Hard","Swift","Array","Dynamic Programming"]},{"location":"solutions/hard/max-dot-product-of-two-subsequences/#description","title":"Description","text":"<p>LeetCode Problem 1458. Max Dot Product of Two Subsequences</p> <p>Given two arrays <code>nums1</code> and <code>nums2</code>.</p> <p>Return the maximum dot product between non-empty subsequences of <code>nums1</code> and <code>nums2</code> with the same length.</p> <p>A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>[2,3,5]</code> is a subsequence of <code>[1,2,3,4,5]</code> while <code>[1,5,3]</code> is not).</p>","tags":["Hard","Swift","Array","Dynamic Programming"]},{"location":"solutions/hard/max-dot-product-of-two-subsequences/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Array","Dynamic Programming"]},{"location":"solutions/hard/median-of-two-sorted-arrays/","title":"Median of Two Sorted Arrays","text":"","tags":["Hard","Swift","Array","Binary Search","Divide and Conquer"]},{"location":"solutions/hard/median-of-two-sorted-arrays/#description","title":"Description","text":"<p>LeetCode Problem 4. Median of Two Sorted Arrays</p> <p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return the median of the two sorted arrays.</p> <p>The overall run time complexity should be \\(O(\\log(m+n))\\).</p>","tags":["Hard","Swift","Array","Binary Search","Divide and Conquer"]},{"location":"solutions/hard/median-of-two-sorted-arrays/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Array","Binary Search","Divide and Conquer"]},{"location":"solutions/hard/merge-k-sorted-lists/","title":"Merge k Sorted Lists","text":"","tags":["Hard","Swift","Linked List","Divide and Conquer","Heap (Priority Queue)","Merge Sort"]},{"location":"solutions/hard/merge-k-sorted-lists/#description","title":"Description","text":"<p>LeetCode Problem 23. Merge k Sorted Lists</p> <p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p> <p>Merge all the linked-lists into one sorted linked-list and return it.</p>","tags":["Hard","Swift","Linked List","Divide and Conquer","Heap (Priority Queue)","Merge Sort"]},{"location":"solutions/hard/merge-k-sorted-lists/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Linked List","Divide and Conquer","Heap (Priority Queue)","Merge Sort"]},{"location":"solutions/hard/n-queens-2/","title":"N-Queens II","text":"","tags":["Hard","Swift","Backtracking"]},{"location":"solutions/hard/n-queens-2/#description","title":"Description","text":"<p>LeetCode Problem 52. N-Queens II</p> <p>The n-queens puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p> <p>Given an integer <code>n</code>, return the number of distinct solutions to the n-queens puzzle.</p>","tags":["Hard","Swift","Backtracking"]},{"location":"solutions/hard/n-queens-2/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Backtracking"]},{"location":"solutions/hard/number-of-ways-to-stay-in-the-same-place-after-some-steps/","title":"Number of Ways to Stay in the Same Place After Some Steps","text":"","tags":["Hard","Swift","Dynamic Programming"]},{"location":"solutions/hard/number-of-ways-to-stay-in-the-same-place-after-some-steps/#description","title":"Description","text":"<p>LeetCode Problem 1269. Number of Ways to Stay in the Same Place After Some Steps</p> <p>You have a pointer at index <code>0</code> in an array of size <code>arrLen</code>. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).</p> <p>Given two integers <code>steps</code> and <code>arrLen</code>, return the number of ways such that your pointer is still at index <code>0</code> after exactly <code>steps</code> steps. Since the answer may be too large, return it modulo <code>10</code><sup>9</sup><code>+ 7</code>.</p>","tags":["Hard","Swift","Dynamic Programming"]},{"location":"solutions/hard/number-of-ways-to-stay-in-the-same-place-after-some-steps/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Dynamic Programming"]},{"location":"solutions/hard/parallel-courses-3/","title":"Parallell Courses III","text":"","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/parallel-courses-3/#description","title":"Description","text":"<p>LeetCode Problem 2050. Parallel Courses III</p> <p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given a 2D integer array <code>relations</code> where <code>relations[j] = [prevCoursej, nextCoursej</code> denotes that course <code>prevCoursej</code> has to be completed before course <code>nextCoursej</code> (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where <code>time[i]</code> denotes how many months it takes to complete the <code>(i+1)</code><sup>th</sup> course.</p> <p>You must find the minimum number of months needed to complete all the courses following these rules:</p> <ul> <li>You may start taking a course at any time if the prerequisites are met.</li> <li>Any number of courses can be taken at the same time.</li> </ul> <p>Return the minimum number of months needed to complete all the courses.</p> <p>Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).</p>","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/parallel-courses-3/#solution","title":"Solution","text":"<p>Topological Sorting</p>","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/parallel-courses-3/#intuition","title":"Intuition","text":"<p>To solve this problem, we can use a topological sorting approach. We'll build a directed graph representing the course prerequisites and track the time required to complete each course. By iteratively selecting courses that have all their prerequisites met, we can minimize the time needed to complete all courses.</p>","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/parallel-courses-3/#approach","title":"Approach","text":"<ol> <li> <p>Create a graph representation of course prerequisites using an adjacency list. Initialize an array <code>inDegree</code> to store the in-degrees of each course, and an array <code>courseTime</code> to store the time required to complete each course.</p> </li> <li> <p>Populate the graph based on the relations provided in the input.</p> </li> <li> <p>Initialize a queue for topological sorting and add all courses with no prerequisites to the queue. These are the courses we can start immediately.</p> </li> <li> <p>Initialize a variable <code>completedCourses</code> to keep track of the number of courses completed and <code>months</code> to keep track of the total time spent.</p> </li> <li> <p>While the queue is not empty, do the following:</p> </li> <li>Dequeue a course from the queue.</li> <li>Update <code>completedCourses</code> and <code>months</code> accordingly.</li> <li>For each course that can be taken after completing the dequeued course (based on the graph), decrement its in-degree by 1.</li> <li>Consider the maximum time for the next course after completing its prerequisites.</li> <li> <p>If the in-degree of the course becomes 0, add it to the queue as it can now be taken.</p> </li> <li> <p>After the loop, if <code>completedCourses</code> is equal to <code>n</code>, we have completed all courses, and the value of <code>months</code> is the minimum time required. Return <code>months</code>.</p> </li> <li> <p>If <code>completedCourses</code> is less than <code>n</code>, it means there's a cycle in the course dependencies, and it's not possible to complete all courses. Return -1 in this case.</p> </li> </ol>","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/parallel-courses-3/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n + m)\\), where \\(n\\) is the number of courses and \\(m\\) is the number of prerequisite relationships.</li> <li>Space complexity: \\(O(n)\\), where \\(n\\) is the number of courses.</li> </ul>","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/parallel-courses-3/#code","title":"Code","text":"<p><pre><code>class Solution {\n    func minimumTime(_ n: Int, _ relations: [[Int]], _ time: [Int]) -&gt; Int {\n        // Create the graph and initialize in-degrees\n        var graph = [Int: [Int]]()\n        var inDegree = [Int](repeating: 0, count: n)\n        var courseTime = [Int](repeating: 0, count: n)\n\n        for relation in relations {\n            let prevCourse = relation[0] - 1\n            let nextCourse = relation[1] - 1\n            if graph[prevCourse] == nil {\n                graph[prevCourse] = [nextCourse]\n            } else {\n                graph[prevCourse]?.append(nextCourse)\n            }\n            inDegree[nextCourse] += 1\n        }\n\n        // Initialize the queue with courses having no prerequisites\n        var queue = [Int]()\n        for course in 0..&lt;n {                if inDegree[course] == 0 {\n                queue.append(course)\n            }\n        }\n\n        var completedCourses = 0\n        var months = 0\n\n        while !queue.isEmpty {\n            let currentCourse = queue.removeFirst()\n            completedCourses += 1\n            months = max(months, courseTime[currentCourse] + time[currentCourse])\n\n            if let nextCourses = graph[currentCourse] {\n                for nextCourse in nextCourses {\n                    inDegree[nextCourse] -= 1\n                    courseTime[nextCourse] = max(courseTime[nextCourse], courseTime[currentCourse] + time[currentCourse])\n\n                    if inDegree[nextCourse] == 0 {\n                        queue.append(nextCourse)\n                    }\n                }\n            }\n        }\n\n        if completedCourses == n {\n            return months\n        }\n\n        // In case of a cycle, it's not possible to complete all courses.\n        return -1\n    }\n}\n</code></pre> ///</p>","tags":["Swift","Hard","Topological Sorting","Graph"]},{"location":"solutions/hard/regular-expression-matching/","title":"Regular Expression Matching","text":"","tags":["Hard","Swift","String","Dynamic Programming","Recursion"]},{"location":"solutions/hard/regular-expression-matching/#description","title":"Description","text":"<p>LeetCode Problem 10. Regular Expression Matching</p> <p>Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>'.'</code> and <code>'*'</code> where:</p> <ul> <li><code>'.'</code> Matches any single character.\u200b\u200b\u200b\u200b</li> <li><code>'*'</code> Matches zero or more of the preceding element.</li> </ul> <p>The matching should cover the entire input string (not partial).</p>","tags":["Hard","Swift","String","Dynamic Programming","Recursion"]},{"location":"solutions/hard/regular-expression-matching/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","String","Dynamic Programming","Recursion"]},{"location":"solutions/hard/reverse-nodes-in-k-group/","title":"Reverse Nodes in k-Group","text":"","tags":["Hard","Swift","Linked List","Recursion"]},{"location":"solutions/hard/reverse-nodes-in-k-group/#description","title":"Description","text":"<p>LeetCode Problem 25. Reverse Nodes in k-Group</p> <p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return the modified list.</p> <p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p> <p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p>","tags":["Hard","Swift","Linked List","Recursion"]},{"location":"solutions/hard/reverse-nodes-in-k-group/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Linked List","Recursion"]},{"location":"solutions/hard/substring-with-concatenation-of-all-words/","title":"Substring With Concatenation of All Words","text":"","tags":["Hard","Swift","Hash Table","String","Sliding Window"]},{"location":"solutions/hard/substring-with-concatenation-of-all-words/#description","title":"Description","text":"<p>LeetCode Problem 30. Substring With Concatenation of All Words</p> <p>You are given a string s and an array of strings words. All the strings of words are of the same length.</p> <p>A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.</p> <p>For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.</p>","tags":["Hard","Swift","Hash Table","String","Sliding Window"]},{"location":"solutions/hard/substring-with-concatenation-of-all-words/#solution","title":"Solution","text":"<p>Coming soon\u2026</p>","tags":["Hard","Swift","Hash Table","String","Sliding Window"]},{"location":"solutions/hard/sudoku-solver/","title":"Sudoku Solver","text":"","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#description","title":"Description","text":"<p>LeetCode Problem 37. Sudoku Solver</p> <p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p> <p>A sudoku solution must satisfy all of the following rules:</p> <ol> <li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li> <li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li> <li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li> </ol> <p>The <code>'.'</code> character indicates empty cells.</p>","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#solution","title":"Solution","text":"<p>The Sudoku puzzle can be solved using a backtracking algorithm. We'll start by iterating through the entire board, looking for empty cells. For each empty cell, we'll try to fill it with numbers from '1' to '9' while ensuring that the Sudoku rules are satisfied. If we reach an invalid state, we'll backtrack and try a different number until a valid solution is found or it's determined that the puzzle is unsolvable.</p>","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#approach","title":"Approach","text":"<ol> <li> <p>Create a function <code>solveSudoku</code> that takes a Sudoku board as input.</p> </li> <li> <p>Inside the <code>solveSudoku</code> function, call the <code>solve</code> function to solve the puzzle.</p> </li> <li> <p>The <code>solve</code> function is the heart of the backtracking algorithm. It iterates through the entire board, looking for empty cells. When it finds an empty cell, it tries to fill it with numbers from '1' to '9'.</p> </li> <li> <p>For each number, it checks if it's a valid move according to the Sudoku rules using the <code>isValid</code> function.</p> </li> <li> <p>If a number is valid, it fills the cell with that number and recursively calls the <code>solve</code> function. If the recursion is successful (i.e., the puzzle is solved), it returns true.</p> </li> <li> <p>If the recursion fails, it means that the current number didn't lead to a valid solution, so it backtracks by setting the cell back to <code>.</code> and continues trying other numbers.</p> </li> <li> <p>The <code>isValid</code> function checks if a number is valid in the current row, column, and 3x3 sub-grid according to the Sudoku rules.</p> </li> </ol>","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#complexity","title":"Complexity","text":"","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#time-complexity","title":"Time complexity:","text":"<p>The backtracking algorithm explores possible solutions, and in the worst case, it might try all possibilities, which is exponential. So, the time complexity is \\(O(9^{n^{2}})\\), where \\(n\\) is the size of the Sudoku board (usually 9x9).</p>","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#space-complexity","title":"Space complexity:","text":"<p>The space complexity is \\(O(n^{2})\\) to store the Sudoku board, where n is the size of the board. The recursive call stack also contributes to space complexity, but it's bounded by the size of the board, so it's \\(O(n^{2})\\).</p>","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/sudoku-solver/#code","title":"Code","text":"<pre><code>class Solution {\n    func solveSudoku(_ board: inout [[Character]]) {\n        solve(&amp;board)\n    }\n\n    func solve(_ board: inout [[Character]]) -&gt; Bool {\n        for i in 0..&lt;9 {\n            for j in 0..&lt;9 {\n                if board[i][j] == \".\" {\n                    for num in \"123456789\" {\n                        if isValid(board, i, j, num) {\n                            board[i][j] = num\n                            if solve(&amp;board) {\n                                return true\n                            }\n                            board[i][j] = \".\"\n                        }\n                    }\n                    return false\n                }\n            }\n        }\n        return true\n    }\n\n    func isValid(_ board: [[Character]], _ row: Int, _ col: Int, _ num: Character) -&gt; Bool {\n        for i in 0..&lt;9 {\n            if board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num {\n                return false\n            }\n        }\n        return true\n    }\n}\n</code></pre>","tags":["Hard","Swift","Array","Hash Table","Back Tracking","Matrix"]},{"location":"solutions/hard/wildcard-matching-45/","title":"Wildcard Matching","text":"","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#description","title":"Description","text":"<p>LeetCode Problem 45. Wildcard Matching</p> <p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:</p> <ul> <li>'?' Matches any single character.</li> <li>'*' Matches any sequence of characters (including the empty sequence).</li> </ul> <p>The matching should cover the entire input string (not partial).</p>","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#solution","title":"Solution","text":"<p>We are given an input string <code>s</code> and a pattern string <code>p</code>, where the pattern can contain wildcard characters '?' and '*'. The problem is to determine if the pattern matches the entire input string. To solve this problem, we can use a recursive approach with memoization to avoid redundant calculations.</p>","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#approach","title":"Approach","text":"<p>We'll use a recursive function <code>isMatchRecursive</code> that checks if the pattern matches the input string. We have two pointers, one for the input string (<code>sIndex</code>) and one for the pattern (<code>pIndex</code>). We consider the following cases:</p> <ol> <li> <p>If <code>pIndex</code> reaches the end of the pattern, we check if <code>sIndex</code> also reached the end of the input string. If so, we have a match.</p> </li> <li> <p>If <code>p[pIndex]</code> is '*', we have two choices:</p> <ol> <li>Use '*' to match nothing in the input string and increment <code>pIndex</code>.</li> <li>Use '*' to match one or more characters in the input string and increment <code>sIndex</code>.</li> </ol> </li> <li> <p>If <code>p[pIndex]</code> is a regular character or '?', we check if it matches the current character in the input string (<code>s[sIndex]</code>). If there is a match, we increment both <code>sIndex</code> and <code>pIndex</code>.</p> </li> </ol> <p>We also use memoization to store the results of subproblems, preventing redundant calculations. If we have already solved a particular subproblem, we return the result from the memoization array.</p>","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#complexity","title":"Complexity","text":"","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#time-complexity","title":"Time complexity:","text":"<p>The time complexity of this solution is \\(O(s * p)\\), where s is the length of the input string and p is the length of the pattern. This is because in the worst case, we may need to fill in the entire memoization array, and each cell requires constant time to compute.</p>","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#space-complexity","title":"Space complexity:","text":"<p>The space complexity is \\(O(s * p)\\) as well, since we use a memoization array to store the results of subproblems.</p>","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/hard/wildcard-matching-45/#code","title":"Code","text":"<pre><code>func isMatch(_ s: String, _ p: String) -&gt; Bool {\n    var memo = Array(repeating: Array(repeating: false, count: p.count + 1), count: s.count + 1)\n    return isMatchRecursive(Array(s), Array(p), 0, 0, &amp;memo)\n}\n\nfunc isMatchRecursive(_ s: [Character], _ p: [Character], _ sIndex: Int, _ pIndex: Int, _ memo: inout [[Bool]]) -&gt; Bool {\n    if pIndex == p.count {\n        return sIndex == s.count\n    }\n\n    if memo[sIndex][pIndex] {\n        return false\n    }\n\n    var match = false\n\n    if p[pIndex] == \"*\" {\n        match = isMatchRecursive(s, p, sIndex, pIndex + 1, &amp;memo) || (sIndex &lt; s.count &amp;&amp; isMatchRecursive(s, p, sIndex + 1, pIndex, &amp;memo))\n    } else if sIndex &lt; s.count and (s[sIndex] == p[pIndex] or p[pIndex] == \"?\") {\n        match = isMatchRecursive(s, p, sIndex + 1, pIndex + 1, &amp;memo)\n    }\n\n    memo[sIndex][pIndex] = !match\n\n    return match\n}\n</code></pre>","tags":["Hard","Swift","String","Dynamic Programming","Greedy","Recursion"]},{"location":"solutions/medium/add-two-numbers/","title":"Adding Two Numbers as Linked Lists","text":"","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#description","title":"Description","text":"<p>LeetCode Problem 2: Add Two Numbers</p> <p>You are given two linked lists, each representing a non-negative integer. The digits are stored in reverse order, meaning that the ones digit is at the head of the list. You need to add these two numbers and return the result as a linked list. </p>","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#intuition","title":"Intuition","text":"<p>To add two numbers as linked lists, we need to simulate the addition process, just like we do manually on paper. We start from the heads of both lists, add the corresponding digits along with any carry from the previous step, and record the result as a new node in the result list. If the sum of two digits is greater than 9, we carry over the extra digit to the next step.</p>","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#approach","title":"Approach","text":"<ol> <li>Initialize three pointers: <code>l1</code> pointing to the head of the first list, <code>l2</code> pointing to the head of the second list, and <code>dummyHead</code> pointing to a dummy node. Also, initialize variables <code>carry</code> to 0 and <code>current</code> to <code>dummyHead</code>.</li> <li>Traverse both lists simultaneously while there are nodes to process in either list or there is a carry.</li> <li>For each step, calculate the sum of the current nodes' values along with the carry from the previous step.</li> <li>Create a new node with the value being the sum % 10 (to handle the carry).</li> <li>Update the carry for the next step (sum / 10).</li> <li>Move <code>current</code> to the new node.</li> <li>Move <code>l1</code> and <code>l2</code> to their next nodes if available.</li> <li>After the loop, if there is a remaining carry, create a final node with its value and append it to the result list.</li> <li>Return <code>dummyHead.next</code>, which is the head of the resulting linked list.</li> </ol>","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#complexity","title":"Complexity","text":"","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#time-complexity","title":"Time Complexity","text":"<ul> <li>We traverse both linked lists once, so the time complexity is \\(O(max(N, M))\\), where \\(N\\) and \\(M\\) are the lengths of the input linked lists.</li> </ul>","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#space-complexity","title":"Space Complexity","text":"<ul> <li>We use a few extra pointers and variables, but the space complexity is \\(O(max(N, M))\\) as we need to store the result.</li> </ul>","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/add-two-numbers/#code","title":"Code","text":"<pre><code>class Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? {\n        var l1 = l1\n        var l2 = l2\n        var carry = 0\n        let dummyHead = ListNode(0)\n        var current: ListNode? = dummyHead\n\n        while l1 != nil || l2 != nil {\n            let x = l1?.val ?? 0\n            let y = l2?.val ?? 0\n            let sum = x + y + carry\n            carry = sum / 10\n            current?.next = ListNode(sum % 10)\n            current = current?.next\n            if l1 != nil { l1 = l1?.next }\n            if l2 != nil { l2 = l2?.next }\n        }\n\n        if carry &gt; 0 {\n            current?.next = ListNode(carry)\n        }\n\n        return dummyHead.next\n    }\n}\n</code></pre>","tags":["Medium","Linked List","Recursion","Math"]},{"location":"solutions/medium/container-with-most-water/","title":"Container wih Most Water","text":"","tags":["Medium","Swift","Array","Two Pointer","Greedy"]},{"location":"solutions/medium/container-with-most-water/#description","title":"Description","text":"<p>LeetCode Problem 11. Container wih Most Water</p> <p>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</p> <p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p> <p>Return the maximum amount of water a container can store.</p> <p>Notice that you may not slant the container.</p>","tags":["Medium","Swift","Array","Two Pointer","Greedy"]},{"location":"solutions/medium/integer-break/","title":"Integer Break","text":"","tags":["Medium","Swift","Math","Dynamic Programming"]},{"location":"solutions/medium/integer-break/#description","title":"Description","text":"<p>LeetCode Problem 343. Integer Break</p> <p>Given an integer <code>n</code>, break it into the sum of <code>k</code> positive integers, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p> <p>Return the maximum product you can get. </p>","tags":["Medium","Swift","Math","Dynamic Programming"]},{"location":"solutions/medium/integer-break/#solution","title":"Solution","text":"<p>Soon...</p>","tags":["Medium","Swift","Math","Dynamic Programming"]},{"location":"solutions/medium/integer-to-roman/","title":"Integer to Roman","text":"","tags":["Medium","Swift","Hash Table","Math","String"]},{"location":"solutions/medium/integer-to-roman/#description","title":"Description","text":"<p>LeetCode Problem 12. Integer to Roman</p> <p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p> Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 <p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p> <p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p> <p><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.  <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.  <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</p> <p>Given an integer, convert it to a roman numeral.</p>","tags":["Medium","Swift","Hash Table","Math","String"]},{"location":"solutions/medium/longest-palindromic-substring/","title":"Longest Palindromic Substring","text":"","tags":["Medium","Swift","String","Dynamic Programmming"]},{"location":"solutions/medium/longest-palindromic-substring/#description","title":"Description","text":"<p>LeetCode Problem 5. Longest Longest Palindromic Substring</p> <p>Given a string <code>s</code>, return the longest palindromic substring in <code>s</code>.</p>","tags":["Medium","Swift","String","Dynamic Programmming"]},{"location":"solutions/medium/longest-palindromic-substring/#solution","title":"Solution","text":"<p>Coming soon...</p>","tags":["Medium","Swift","String","Dynamic Programmming"]},{"location":"solutions/medium/longest-substring-without-repeating-characters/","title":"Longest Substring Without Repeating Characters","text":"","tags":["Medium","Swift","Hash Table","String","Sliding Window"]},{"location":"solutions/medium/longest-substring-without-repeating-characters/#description","title":"Description","text":"<p>LeetCode Problem 3. Longest Substring Without Repeating Characters</p> <p>Given a string <code>s</code>, find the length of the longest substring without repeating characters.</p>","tags":["Medium","Swift","Hash Table","String","Sliding Window"]},{"location":"solutions/medium/reverse-integer/","title":"Reverse Integer","text":"","tags":["Medium","Swift","Math"]},{"location":"solutions/medium/reverse-integer/#description","title":"Description","text":"<p>LeetCode Problem 7. Reverse Integer</p> <p>Given a signed 32-bit integer <code>x</code>, return <code>x</code> with its digits reversed. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then return <code>0</code>.</p> <p>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</p>","tags":["Medium","Swift","Math"]},{"location":"solutions/medium/reverse-integer/#solution","title":"Solution","text":"<p>Coming soon...</p>","tags":["Medium","Swift","Math"]},{"location":"solutions/medium/string-to-integer-atoi/","title":"String to Integer (atoi)","text":"","tags":["Medium","Swift","String"]},{"location":"solutions/medium/string-to-integer-atoi/#description","title":"Description","text":"<p>LeetCode Problem 8: String to Integer (atoi)</p> <p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++'s <code>atoi</code> function).</p> <p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p> <ol> <li> <p>Read in and ignore any leading whitespace.</p> </li> <li> <p>Check if the next character (if not already at the end of the string) is <code>'-'</code> or <code>'+'</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</p> </li> <li> <p>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</p> </li> <li> <p>Convert these digits into an integer (i.e. <code>\"123\" -&gt; 123</code>, <code>\"0032\" -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</p> </li> <li> <p>If the integer is out of the 32-bit signed integer range <code>[-2^31, 2^31 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2^31</code> should be clamped to <code>-2^31</code>, and integers greater than <code>2^31 - 1</code> should be clamped to <code>2^31 - 1</code>.</p> </li> <li> <p>Return the integer as the final result.</p> </li> </ol> <p>Note:</p> <ul> <li> <p>Only the space character <code>' '</code> is considered a whitespace character.</p> </li> <li> <p>Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. ```</p> </li> </ul>","tags":["Medium","Swift","String"]},{"location":"solutions/medium/string-to-integer-atoi/#examples","title":"Examples","text":"Example 1Example 2Example 3 <pre><code>Input: s = \"42\"\nOutput: 42\n\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n\nStep 3: \"42\" (\"42\" is read in)\n\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\n</code></pre> <pre><code>Input: s = \"-42\"\nOutput: -42\n\nExplanation:\nStep 1: \"    -42\" (leading whitespace is read and ignored)\n\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n\nStep 3: \"   -42\" (\"42\" is read in)              \nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\n</code></pre> <pre><code>Input: s = \"4193 with words\"\nOutput: 4193\n\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)       \nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\n</code></pre>","tags":["Medium","Swift","String"]},{"location":"solutions/medium/string-to-integer-atoi/#intuition","title":"Intuition","text":"<p>The problem requires parsing a given string to convert it into a 32-bit signed integer while considering leading whitespace, signs, and integer overflow. The solution involves careful handling of each step of the algorithm.</p>","tags":["Medium","Swift","String"]},{"location":"solutions/medium/string-to-integer-atoi/#approach","title":"Approach","text":"<ol> <li> <p>Trim leading whitespace from the input string using <code>trimmingCharacters(in:)</code>.</p> </li> <li> <p>Check for signs ('+' or '-') and set the sign variable accordingly. Remove the sign character if present.</p> </li> <li> <p>Iterate through the remaining characters, checking if they are digits. Convert them into an integer and update the result.</p> </li> <li> <p>Handle integer overflow by checking whether the result exceeds the 32-bit signed integer range during each iteration. If it does, return the clamped result.</p> </li> <li> <p>Return the final integer result with the appropriate sign.</p> </li> </ol>","tags":["Medium","Swift","String"]},{"location":"solutions/medium/string-to-integer-atoi/#complexity","title":"Complexity","text":"<ul> <li> <p>Time complexity: \\(O(n)\\) where \\(n\\) is the length of the input string. We iterate through the string once.</p> </li> <li> <p>Space complexity: \\(O(1)\\) as we use a constant amount of extra space for variables.</p> </li> </ul>","tags":["Medium","Swift","String"]},{"location":"solutions/medium/string-to-integer-atoi/#code","title":"Code","text":"<pre><code>class Solution {\n    func myAtoi(_ s: String) -&gt; Int {\n        // Step 1: Trim leading whitespace\n        let str = s.trimmingCharacters(in: .whitespaces)\n        // If the string is empty after trimming, return 0\n        guard !str.isEmpty else { return 0 }\n\n        var sign = 1\n        var result = 0\n        var i = str.startIndex\n\n        // Step 2: Check for signs ('+' or '-') and set the sign variable\n        if str[i] == \"+\" || str[i] == \"-\" {\n            sign = str[i] == \"-\" ? -1 : 1\n            i = str.index(after: i) // Move to the next character\n        }\n\n        // Step 3: Iterate through the remaining characters\n        while i &lt; str.endIndex, str[i].isNumber {\n            let digit = Int(String(str[i]))!\n\n            // Step 4: Handle integer overflow\n            if result &gt; (Int(Int32.max) - digit) / 10 {\n                return sign == 1 ? Int(Int32.max) : Int(Int32.min)\n            }\n\n            // Convert the digit to an integer and update the result\n            result = result * 10 + digit\n            i = str.index(after: i) // Move to the next character\n        }\n\n        // Step 5: Return the final integer result with the appropriate sign\n        return sign * result\n    }\n}\n</code></pre>","tags":["Medium","Swift","String"]},{"location":"solutions/medium/validate-binary-tree-nodes/","title":"Validate Binary Tree Nodes","text":"","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/validate-binary-tree-nodes/#description","title":"Description","text":"<p>LeetCode Problem 1361. Validate Binary Tree Nodes</p> <p>You have <code>n</code> binary tree nodes numbered from <code>0</code> to <code>n - 1</code>where node <code>i</code> has two children <code>leftChild[i]</code> and <code>rightChild[i]</code>, return true if and only if all the given nodes form exactly one valid binary tree. </p> <p>If node<code>i</code> has no left child then<code>leftChild[i]</code> will equal <code>-1</code>, similarly for the right child. </p> <p>Note that the nodes have no values and that we only use the node numbers in this problem.</p>","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/validate-binary-tree-nodes/#solution","title":"Solution","text":"","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/validate-binary-tree-nodes/#intuition","title":"Intuition","text":"<p>To solve this problem, we need to validate whether the given list of binary tree nodes forms exactly one valid binary tree. A valid binary tree has the following properties:</p> <ol> <li>It has one and only one root node.</li> <li>Each non-root node has exactly one parent.</li> <li>There are no cycles in the tree.</li> <li>The tree must be connected.</li> </ol> <p>We'll use these properties to validate the tree.</p>","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/validate-binary-tree-nodes/#approach","title":"Approach","text":"<p>We can approach this problem by simulating the creation of a binary tree while keeping track of the parent of each node. We'll use two arrays: <code>parent</code> to store the parent of each node, and <code>seen</code> to check if we've seen a node before. The idea is to iterate through the given <code>leftChild</code> and <code>rightChild</code> arrays and ensure that each child node has only one parent. Additionally, we will check if the tree is connected.</p> <ol> <li> <p>Initialize two arrays, <code>parent</code> and <code>seen</code>, both of size <code>n</code>. Initialize <code>parent</code> with -1 and <code>seen</code> as false for all nodes.</p> </li> <li> <p>Iterate through the <code>leftChild</code> and <code>rightChild</code> arrays.</p> <ul> <li>For each node <code>i</code>, check if its left child <code>leftChild[i]</code> is not -1 and if we haven't seen it before (i.e., <code>seen[leftChild[i]]</code> is false).<ul> <li>If true, mark <code>seen[leftChild[i]]</code> as true and set <code>parent[leftChild[i]]</code> to <code>i</code>.</li> <li>If false, return false as this means the same child node has two parents, violating the binary tree property.</li> </ul> </li> <li>Repeat the same check for the right child.</li> </ul> </li> <li> <p>After iterating through both arrays, check if there is one and only one root node (a node without a parent). Count the number of root nodes by counting the nodes with -1 in the <code>parent</code> array.</p> </li> <li> <p>If there is exactly one root node (count of root nodes is 1) and there are no cycles (all nodes are connected and have only one parent), return true. Otherwise, return false.</p> </li> </ol>","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/validate-binary-tree-nodes/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\) where \\(n\\) is the number of nodes. We iterate through the <code>leftChild</code> and <code>rightChild</code> arrays once, each taking \\(O(n)\\) time. The depth-first search for connectedness also takes \\(O(n)\\) time.</li> <li>Space complexity: \\(O(n)\\) to store the <code>parent</code>, <code>seen</code>, and <code>visited</code> arrays.</li> </ul>","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/validate-binary-tree-nodes/#code","title":"Code","text":"<pre><code>func validateBinaryTreeNodes(_ n: Int, _ leftChild: [Int], _ rightChild: [Int]) -&gt; Bool {\n    var parent = [Int](repeating: -1, count: n)\n    var seen = [Bool](repeating: false, count: n)\n\n    for i in 0..&lt;n {\n        if leftChild[i] != -1 {\n            if seen[leftChild[i]] {\n                return false // The same child node has two parents.\n            }\n            seen[leftChild[i]] = true\n            parent[leftChild[i]] = i\n        }\n\n        if rightChild[i] != -1 {\n            if seen[rightChild[i]] {\n                return false // The same child node has two parents.\n            }\n            seen[rightChild[i]] = true\n            parent[rightChild[i]] = i\n        }\n    }\n\n    var rootCount = 0\n    var rootNode = -1\n\n    for i in 0..&lt;n {\n        if parent[i] == -1 {\n            rootCount += 1\n            rootNode = i\n            if rootCount &gt; 1 {\n                 return false // Multiple root nodes.\n            }\n        }\n    }\n\n    if rootCount != 1 {\n        return false // No root or multiple roots.\n    }\n\n    // Check if the tree is connected.\n    var visited = [Bool](repeating: false, count: n)\n\n    func dfs(node: Int) {\n        visited[node] = true\n        if leftChild[node] != -1 &amp;&amp; !visited[leftChild[node]] {\n            dfs(node: leftChild[node])\n        }\n        if rightChild[node] != -1 &amp;&amp; !visited[rightChild[node]] {\n            dfs(node: rightChild[node])\n        }\n    }\n\n    dfs(node: rootNode)\n\n    for i in 0..&lt;n {\n        if !visited[i] {\n            return false // The tree is not connected.\n        }\n    }\n\n    return true\n}\n</code></pre>","tags":["Medium","Tree","Depth First Search","Breadth-First Search","Union Find","Graph","Binary Tree"]},{"location":"solutions/medium/zigzag-conversation/","title":"Zigzag Conversation","text":"","tags":["Medium","Swift"]},{"location":"solutions/medium/zigzag-conversation/#description","title":"Description","text":"<p>LeetCode Problem 6. Zigzag Conversion</p> <p>The string <code>\"PAYPALISHIRING\"</code> is written in a zigzag pattern on a given number of rows like this:</p> <pre><code>P   A   H   N\nA P L S I I G\nY   I   R\n</code></pre> <p>And then read line by line: <code>\"PAHNAPLSIIGYIR\"</code></p> <p>Write the code that will take a string and make this conversion given a number of rows:</p> <pre><code>string convert(string s, int numRows);\n</code></pre>","tags":["Medium","Swift"]},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#array","title":"Array","text":"<ul> <li>Remove Duplicates from Sorted Array</li> <li>Two Sum</li> <li>Constrained Subsequence Sum</li> <li>Max Dot Product of Two Subsequences</li> <li>Median of Two Sorted Arrays</li> <li>Sudoku Solver</li> <li>Container wih Most Water</li> </ul>"},{"location":"tags/#back-tracking","title":"Back Tracking","text":"<ul> <li>Sudoku Solver</li> </ul>"},{"location":"tags/#backtracking","title":"Backtracking","text":"<ul> <li>N-Queens II</li> </ul>"},{"location":"tags/#binary-search","title":"Binary Search","text":"<ul> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#binary-tree","title":"Binary Tree","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#breadth-first-search","title":"Breadth-First Search","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#depth-first-search","title":"Depth First Search","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#divide-and-conquer","title":"Divide and Conquer","text":"<ul> <li>Median of Two Sorted Arrays</li> <li>Merge k Sorted Lists</li> </ul>"},{"location":"tags/#dynamic-programming","title":"Dynamic Programming","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Longest Valid Parentheses</li> <li>Max Dot Product of Two Subsequences</li> <li>Number of Ways to Stay in the Same Place After Some Steps</li> <li>Regular Expression Matching</li> <li>Wildcard Matching</li> <li>Integer Break</li> </ul>"},{"location":"tags/#dynamic-programmming","title":"Dynamic Programmming","text":"<ul> <li>Longest Palindromic Substring</li> </ul>"},{"location":"tags/#easy","title":"Easy","text":"<ul> <li>Backspace String Compare</li> <li>Palindrome Number</li> <li>Pascals Triangle II</li> <li>Remove Duplicates from Sorted Array</li> <li>Roman to Integer</li> <li>Tenth Line</li> <li>Two Sum</li> </ul>"},{"location":"tags/#graph","title":"Graph","text":"<ul> <li>Parallell Courses III</li> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#greedy","title":"Greedy","text":"<ul> <li>Wildcard Matching</li> <li>Container wih Most Water</li> </ul>"},{"location":"tags/#hard","title":"Hard","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Longest Valid Parentheses</li> <li>Max Dot Product of Two Subsequences</li> <li>Median of Two Sorted Arrays</li> <li>Merge k Sorted Lists</li> <li>N-Queens II</li> <li>Number of Ways to Stay in the Same Place After Some Steps</li> <li>Parallell Courses III</li> <li>Regular Expression Matching</li> <li>Reverse Nodes in k-Group</li> <li>Substring With Concatenation of All Words</li> <li>Sudoku Solver</li> <li>Wildcard Matching</li> </ul>"},{"location":"tags/#hash-table","title":"Hash Table","text":"<ul> <li>Roman to Integer</li> <li>Two Sum</li> <li>Substring With Concatenation of All Words</li> <li>Sudoku Solver</li> <li>Integer to Roman</li> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#heap-priority-queue","title":"Heap (Priority Queue)","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Merge k Sorted Lists</li> </ul>"},{"location":"tags/#linked-list","title":"Linked List","text":"<ul> <li>Merge k Sorted Lists</li> <li>Reverse Nodes in k-Group</li> <li>Add Two Numbers</li> </ul>"},{"location":"tags/#math","title":"Math","text":"<ul> <li>Palindrome Number</li> <li>Roman to Integer</li> <li>Add Two Numbers</li> <li>Integer Break</li> <li>Integer to Roman</li> <li>Reverse Integer</li> </ul>"},{"location":"tags/#matrix","title":"Matrix","text":"<ul> <li>Sudoku Solver</li> </ul>"},{"location":"tags/#medium","title":"Medium","text":"<ul> <li>Add Two Numbers</li> <li>Container wih Most Water</li> <li>Integer Break</li> <li>Integer to Roman</li> <li>Longest Palindromic Substring</li> <li>Longest Substring Without Repeating Characters</li> <li>Reverse Integer</li> <li>String to Integer (atoi)</li> <li>Validate Binary Tree Nodes</li> <li>Zigzag Conversation</li> </ul>"},{"location":"tags/#merge-sort","title":"Merge Sort","text":"<ul> <li>Merge k Sorted Lists</li> </ul>"},{"location":"tags/#monotonic-queue","title":"Monotonic Queue","text":"<ul> <li>Constrained Subsequence Sum</li> </ul>"},{"location":"tags/#queue","title":"Queue","text":"<ul> <li>Constrained Subsequence Sum</li> </ul>"},{"location":"tags/#recursion","title":"Recursion","text":"<ul> <li>Regular Expression Matching</li> <li>Reverse Nodes in k-Group</li> <li>Wildcard Matching</li> <li>Add Two Numbers</li> </ul>"},{"location":"tags/#shell","title":"Shell","text":"<ul> <li>Tenth Line</li> </ul>"},{"location":"tags/#simulation","title":"Simulation","text":"<ul> <li>Backspace String Compare</li> </ul>"},{"location":"tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>Constrained Subsequence Sum</li> <li>Substring With Concatenation of All Words</li> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#stack","title":"Stack","text":"<ul> <li>Backspace String Compare</li> <li>Longest Valid Parentheses</li> </ul>"},{"location":"tags/#string","title":"String","text":"<ul> <li>Backspace String Compare</li> <li>Roman to Integer</li> <li>Longest Valid Parentheses</li> <li>Regular Expression Matching</li> <li>Substring With Concatenation of All Words</li> <li>Wildcard Matching</li> <li>Integer to Roman</li> <li>Longest Palindromic Substring</li> <li>Longest Substring Without Repeating Characters</li> <li>String to Integer (atoi)</li> </ul>"},{"location":"tags/#swift","title":"Swift","text":"<ul> <li>Backspace String Compare</li> <li>Palindrome Number</li> <li>Pascals Triangle II</li> <li>Remove Duplicates from Sorted Array</li> <li>Roman to Integer</li> <li>Two Sum</li> <li>Longest Valid Parentheses</li> <li>Max Dot Product of Two Subsequences</li> <li>Median of Two Sorted Arrays</li> <li>Merge k Sorted Lists</li> <li>N-Queens II</li> <li>Number of Ways to Stay in the Same Place After Some Steps</li> <li>Parallell Courses III</li> <li>Regular Expression Matching</li> <li>Reverse Nodes in k-Group</li> <li>Substring With Concatenation of All Words</li> <li>Sudoku Solver</li> <li>Wildcard Matching</li> <li>Container wih Most Water</li> <li>Integer Break</li> <li>Integer to Roman</li> <li>Longest Palindromic Substring</li> <li>Longest Substring Without Repeating Characters</li> <li>Reverse Integer</li> <li>String to Integer (atoi)</li> <li>Zigzag Conversation</li> </ul>"},{"location":"tags/#topological-sorting","title":"Topological Sorting","text":"<ul> <li>Parallell Courses III</li> </ul>"},{"location":"tags/#tree","title":"Tree","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"},{"location":"tags/#two-pointer","title":"Two Pointer","text":"<ul> <li>Container wih Most Water</li> </ul>"},{"location":"tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>Backspace String Compare</li> <li>Remove Duplicates from Sorted Array</li> </ul>"},{"location":"tags/#union-find","title":"Union Find","text":"<ul> <li>Validate Binary Tree Nodes</li> </ul>"}]}